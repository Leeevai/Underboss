# GitLab CI/CD Pipeline for Underboss Backend
#
# This pipeline runs automated tests on every commit and merge request
# - pytest suite via make check.pytest
# - comprehensive bash test script

# Define stages for the pipeline
stages:
  - test
  - integration

# Global variables
variables:
  # Python configuration
  PYTHON_VERSION: "3.11"
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"
  
  # PostgreSQL configuration
  POSTGRES_DB: "underboss"
  POSTGRES_USER: "underboss"
  POSTGRES_PASSWORD: "test_password"
  POSTGRES_HOST_AUTH_METHOD: "trust"
  
  # Application configuration
  APP_PORT: "5000"
  APP_URL: "http://localhost:5000"
  FLASK_TESTER_APP: "http://localhost:5000"
  FLASK_TESTER_USER: "login"
  FLASK_TESTER_PASS: "password"
  FLASK_TESTER_AUTH: "basic"
  
  # Database connection for app
  DBCONN: "host=postgres user=underboss dbname=underboss password=test_password"

# Cache pip packages to speed up builds
cache:
  paths:
    - .cache/pip
    - venv/

# Base configuration for all test jobs
.test_base:
  image: python:${PYTHON_VERSION}
  services:
    - postgres:15
  before_script:
    # Install system dependencies
    - apt-get update -qq
    - apt-get install -y -qq postgresql-client make curl jq netcat-traditional
    
    # Create Python virtual environment
    - python -m venv venv
    - source venv/bin/activate
    
    # Upgrade pip and install dependencies
    - pip install --upgrade pip
    - pip install -r requirements.txt
    - pip install -r dev-requirements.txt
    
    # Wait for PostgreSQL to be ready
    - |
      echo "Waiting for PostgreSQL..."
      until PGPASSWORD=$POSTGRES_PASSWORD psql -h postgres -U $POSTGRES_USER -d postgres -c '\q' 2>/dev/null; do
        echo "PostgreSQL is unavailable - sleeping"
        sleep 1
      done
      echo "PostgreSQL is up"
    
    # Create database if it doesn't exist
    - |
      PGPASSWORD=$POSTGRES_PASSWORD psql -h postgres -U $POSTGRES_USER -d postgres -c "SELECT 1 FROM pg_database WHERE datname = '$POSTGRES_DB'" | grep -q 1 || \
      PGPASSWORD=$POSTGRES_PASSWORD psql -h postgres -U $POSTGRES_USER -d postgres -c "CREATE DATABASE $POSTGRES_DB"
    
    # Create local.mk for CI environment
    - |
      cat > local.mk << EOF
      APP       = underboss
      PYTHON    = python3
      DELAY     = 2
      LOOP      = 8
      PORT      = ${APP_PORT}
      ADMIN     = calvin:hobbes
      NOADM     = hobbes:calvin
      USER      = underboss
      HOST      = localhost
      SERVER    = localhost
      APP_URL   = http://localhost:${APP_PORT}
      DBCONN    = host=postgres user=${POSTGRES_USER} dbname=${POSTGRES_DB} password=${POSTGRES_PASSWORD}
      EOF
    
    # Display environment info
    - echo "Python version:" && python --version
    - echo "Pip version:" && pip --version
    - echo "PostgreSQL version:" && PGPASSWORD=$POSTGRES_PASSWORD psql -h postgres -U $POSTGRES_USER -d postgres -c 'SELECT version();'

# Job 1: Run pytest suite via make check.pytest
pytest_suite:
  extends: .test_base
  stage: test
  script:
    - source venv/bin/activate
    
    # Run make check.pytest (external tests)
    - echo "Running pytest suite via make check.pytest..."
    - make check.pytest
  
  artifacts:
    when: always
    reports:
      junit: test-results.xml
    paths:
      - test-results.xml
      - app.log
    expire_in: 1 week
  
  coverage: '/(?i)total.*? (100(?:\.0+)?\%|[1-9]?\d(?:\.\d+)?\%)$/'
  
  # Run on all branches and merge requests
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH'

# Job 2: Run comprehensive bash test script
comprehensive_tests:
  extends: .test_base
  stage: integration
  script:
    - source venv/bin/activate
    
    # Make comprehensive test script executable
    - chmod +x comprehensive_test.sh
    
    # Start the Flask server in background
    - echo "Starting Flask server..."
    - make running
    
    # Wait for server to be ready
    - |
      echo "Waiting for server to start..."
      for i in {1..30}; do
        if curl -s http://localhost:${APP_PORT}/system/info > /dev/null 2>&1; then
          echo "Server is ready!"
          break
        fi
        echo "Attempt $i/30: Server not ready yet..."
        sleep 2
      done
    
    # Verify server is running
    - curl -f http://localhost:${APP_PORT}/system/info || (echo "Server failed to start!" && exit 1)
    
    # Run comprehensive test script
    - echo "Running comprehensive test script..."
    - ./comprehensive_test.sh
    
    # Stop the server
    - make stop || true
  
  after_script:
    # Cleanup: ensure resources are freed
    - |
      if [ -f app.pid ]; then
        kill $(cat app.pid) 2>/dev/null || true
        rm -f app.pid
      fi
      pkill -f "flask run" || true
  
  artifacts:
    when: always
    paths:
      - app.log
      - app.pid
    expire_in: 1 week
  
  # Run on main branch and merge requests only
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
  
  # Allow this job to fail without blocking the pipeline
  allow_failure: true
